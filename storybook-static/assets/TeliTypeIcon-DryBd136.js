import{j as L}from"./emotion-react-jsx-runtime.browser.esm-CUMkBk-e.js";import{u as k}from"./OntologyStyles-3vIeTx_k.js";import{A as R}from"./Avatar-DWT_ExSU.js";var $=Object.defineProperty,N=(l,e,t)=>e in l?$(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t,o=(l,e,t)=>(N(l,typeof e!="symbol"?e+"":e,t),t),x=Object.defineProperty,_=(l,e,t)=>e in l?x(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t,u=(l,e,t)=>(_(l,typeof e!="symbol"?e+"":e,t),t),S=(l,e,t)=>{if(!e.has(l))throw TypeError("Cannot "+t)},U=(l,e,t)=>(S(l,e,"read from private field"),t?t.call(l):e.get(l)),D=(l,e,t)=>{if(e.has(l))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(l):e.set(l,t)},A=(l,e,t,s)=>(S(l,e,"write to private field"),e.set(l,t),t),O=(l,e,t)=>(S(l,e,"access private method"),t);const P="Cannot have an empty URI",j="W3C/XML prefixes must end with a : (colon) character",W="Unknown Prefix ",y=l=>!l;class g{constructor(e,t,s="http://www.w3.org/2000/01/rdf-schema#Resource",i){if(u(this,"uri"),u(this,"types"),u(this,"service"),this.uri="",this.types=[],this.service=e,i){if(i.uri.value in this.service.nodes){const r=this.service.nodes[i.uri.value];return i._type&&i._type.value.split(" ").forEach(a=>{r.types.includes(a)||r.types.push(a)}),r}this.uri=i.uri.value,i._type&&!this.types.includes(i._type.value)&&(this.types=i._type.value.split(" "))}else{if(t){if(this.uri=t,t in this.service.nodes){const r=this.service.nodes[t];if(r.constructor.name!=this.constructor.name)throw Error(`Attempt to create a different type of object with uri ${t}, existing: ${r.constructor.name}, new: ${this.constructor.name}`);return s&&!r.types.includes(s)&&r.types.push(s),r}}else this.uri=this.service.mintUri();if(s&&!this.types.includes(s))this.types.push(s),this.service.instantiate(s,this.uri);else throw new Error("An RDFResource requires a type, or a statement PropertyQuery object")}this.service.nodes[this.uri]=this}async addLiteral(e,t,s,i,r=!1){if(y(e))throw new Error("Cannot have an empty predicate");if(y(t))throw new Error("Cannot have empty text in a triple");return await this.service.insertTriple(this.uri,e,t,"LITERAL",s,i,r)}async addLabel(e,t,s="xsd:string",i=!1){if(y(e))throw new Error("invalid label string");await this.addLiteral(this.service.rdfsLabel,e,t,s,i)}async addComment(e,t,s="xsd:string",i=!1){if(y(e))throw new Error("invalid comment string");await this.addLiteral(this.service.rdfsComment,e,t,s,i)}async setTitle(e,t,s="xsd:string",i=!0){if(y(e))throw new Error("invalid title string");this.addLiteral(this.service.dcTitle,e,t,s,i)}async setPublished(e,t,s="xsd:string",i=!0){if(y(e))throw new Error("invalid published date");this.addLiteral(this.service.dcPublished,e,t,s,i)}async setPrefLabel(e,t,s="xsd:string",i=!0){if(y(e))throw new Error("invalid skos:prefLabel");this.addLiteral(`${this.service.skos}prefLabel`,e,t,s,i)}async setAltLabel(e,t,s="xsd:string",i=!1){if(y(e))throw new Error("invalid skos:altLabel");this.addLiteral(`${this.service.skos}altLabel`,e,t,s,i)}async countRelated(e){const t=`SELECT (count(DISTINCT ?item) as ?count) WHERE {<${this.uri}> ${e} ?item}`,s=await this.service.runQuery(t);if(s.results.bindings.length<1)return 0;if(s.results.bindings.length>1)throw"Count query should never return more than one binding";return s.results.bindings[0].count?Number(s.results.bindings[0].count.value):0}async getRelated(e){var t;let s="";e&&(s=` BIND (<${e}> AS ?predicate) .`);const i=`SELECT ?uri (group_concat(DISTINCT ?type) as ?_type) ?predicate WHERE {${s} <${this.uri}> ?predicate ?uri . OPTIONAL {?uri a ?type} FILTER isIRI(?uri) } GROUP BY ?uri ?predicate`,r=await this.service.runQuery(i);if(!((t=r==null?void 0:r.results)!=null&&t.bindings))return{};const a={};return r.results.bindings.forEach(n=>{const c=new g(this.service,void 0,void 0,n);n.predicate.value in a||(a[n.predicate.value]=[]),a[n.predicate.value].indexOf(c)<0&&a[n.predicate.value].push(c)}),a}async getRelating(e){var t;let s="";e&&(s=` BIND (<${e}> AS ?predicate) .`);const i=`SELECT ?uri (group_concat(DISTINCT ?type) as ?_type) ?predicate WHERE {${s} ?uri ?predicate <${this.uri}> . OPTIONAL {?uri a ?type} } GROUP BY ?uri ?predicate`,r=await this.service.runQuery(i);if(!((t=r==null?void 0:r.results)!=null&&t.bindings))return{};const a={};return r.results.bindings.forEach(n=>{const c=new g(this.service,void 0,void 0,n);n.predicate.value in a||(a[n.predicate.value]=[]),a[n.predicate.value].indexOf(c)<0&&a[n.predicate.value].push(c)}),a}async describeNode(e){let t="";e&&(t=` . OPTIONAL {?invS <${e}> ?invFurther}`);const s=`SELECT ?s ?p ?o ?invP ?invS ?oType ?invType ?invFurther WHERE {
      BIND (<${this.uri}> AS ?s) .
      OPTIONAL {?s ?p ?o OPTIONAL {?o a ?oType} }
      OPTIONAL {?invS ?invP ?s OPTIONAL {?invS a ?invType} ${t} }
    }`,i={literals:{},inLinks:{},outLinks:{},furtherInLinks:[]};return(await this.service.runQuery(s)).results.bindings.forEach(r=>{if(r.p)if(r.o&&r.o.type.toUpperCase()=="LITERAL")Object.keys(i.literals).includes(r.p.value)?i.literals[r.p.value].includes(r.o.value)||i.literals[r.p.value].push(r.o.value):i.literals[r.p.value]=[r.o.value];else{let a={};Object.keys(i.outLinks).includes(r.p.value)?a=i.outLinks[r.p.value]:i.outLinks[r.p.value]=a;let n=[];r.o&&(Object.keys(a).includes(r.o.value)?n=a[r.o.value]:a[r.o.value]=n,r.oType&&!n.includes(r.oType.value)&&n.push(r.oType.value))}if(r.invP&&r.invS){let a={};Object.keys(i.inLinks).includes(r.invP.value)?a=i.inLinks[r.invP.value]:i.inLinks[r.invP.value]=a;let n=[];r.o&&(Object.keys(a).includes(r.invS.value)?n=a[r.invS.value]:a[r.invS.value]=n,r.invType&&!n.includes(r.invType.value)&&n.push(r.invType.value)),r.invFurther&&!i.furtherInLinks.includes(r.invFurther.value)&&i.furtherInLinks.push(r.invFurther.value)}}),i}async getLiterals(e){var t;let s="";e&&(s=` BIND (<${e}> AS ?predicate) .`);const i=`SELECT ?literal ?predicate WHERE {${s} <${this.uri}> ?predicate ?literal . FILTER isLiteral(?literal) }`,r=await this.service.runQuery(i);if(!((t=r==null?void 0:r.results)!=null&&t.bindings))return{};const a={};return r.results.bindings.forEach(n=>{const c=n.literal.value;n.predicate.value in a||(a[n.predicate.value]=[]),a[n.predicate.value].indexOf(c)<0&&a[n.predicate.value].push(c)}),a}async getLabels(){const e=await this.getLiterals(this.service.rdfsLabel);let t=[];return this.service.rdfsLabel in e&&(t=e[this.service.rdfsLabel]),t}async getPrefLabel(){const e=await this.getLiterals(`${this.service.skos}prefLabel`);let t=[];return`${this.service.skos}prefLabel`in e&&(t=e[`${this.service.skos}prefLabel`]),t.length>1&&this.service.warn(`More than one SKOS preferred label on ${this.uri}`),t}async getAltLabels(){const e=await this.getLiterals(`${this.service.skos}altLabel`);let t=[];return`${this.service.skos}altLabel`in e&&(t=e[`${this.service.skos}altLabel`]),t}async getComments(){const e=await this.getLiterals(this.service.rdfsComment);let t=[];return this.service.rdfsComment in e&&(t=e[this.service.rdfsComment]),t}async getDcTitle(){const e=await this.getLiterals(this.service.dcTitle);let t=[];return this.service.dcTitle in e&&(t=e[this.service.dcTitle]),t.length>1&&this.service.warn(`More than one Dublin Core title tag on ${this.uri}`),t}async getDcPublished(){const e=await this.getLiterals(this.service.dcPublished);let t=[];return this.service.dcPublished in e&&(t=e[this.service.dcPublished]),t.length>1&&this.service.warn(`More than one Dublin Core published tag on ${this.uri}`),t}async getDcCreated(){const e=await this.getLiterals(this.service.dcCreated);let t=[];return this.service.dcCreated in e&&(t=e[this.service.dcCreated]),t.length>1&&this.service.warn(`More than one Dublin Core created tag on ${this.uri}`),t}}var w,m,C;class H{constructor(e="http://localhost:3030/",t="ds",s="http://telicent.io/data/",i="",r=!1){D(this,m),u(this,"defaultSecurityLabel"),D(this,w,void 0),u(this,"showWarnings"),u(this,"dataset"),u(this,"triplestoreUri"),u(this,"queryEndpoint"),u(this,"updateEndpoint"),u(this,"dc"),u(this,"xsd"),u(this,"rdf"),u(this,"rdfs"),u(this,"skos"),u(this,"owl"),u(this,"telicent"),u(this,"prefixDict"),u(this,"rdfType"),u(this,"rdfsResource"),u(this,"rdfsLabel"),u(this,"rdfsComment"),u(this,"nodes"),u(this,"dct"),u(this,"dcTitle"),u(this,"dcCreated"),u(this,"dcPublished"),u(this,"classLookup"),u(this,"updateCount"),this.defaultSecurityLabel=i,this.dataset=t,this.triplestoreUri=`${e}${e.endsWith("/")?"":"/"}`,this.queryEndpoint=this.triplestoreUri+t+"/query?query=",this.updateEndpoint=this.triplestoreUri+t+"/update",A(this,w,r),this.updateCount=0,this.showWarnings=!0,this.dc="http://purl.org/dc/elements/1.1/",this.dct="http://purl.org/dc/terms/",this.xsd="http://www.w3.org/2001/XMLSchema#",this.rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#",this.rdfs="http://www.w3.org/2000/01/rdf-schema#",this.owl="http://www.w3.org/2002/07/owl#",this.skos="http://www.w3.org/2004/02/skos/core#",this.telicent="http://telicent.io/ontology/",this.rdfType=`${this.rdf}type`,this.rdfsResource=`${this.rdfs}Resource`,this.rdfsLabel=`${this.rdfs}label`,this.rdfsComment=`${this.rdfs}comment`,this.dcTitle=`${this.dct}title`,this.dcCreated=`${this.dct}created`,this.dcPublished=`${this.dct}published`,this.prefixDict={},this.addPrefix(":",s),this.addPrefix("xsd:",this.xsd),this.addPrefix("dc:",this.dc),this.addPrefix("rdf:",this.rdf),this.addPrefix("rdfs:",this.rdfs),this.addPrefix("rdfs:",this.rdfs),this.addPrefix("skos:",this.skos),this.addPrefix("telicent:",this.telicent),this.addPrefix("foaf:","http://xmlns.com/foaf/0.1/"),this.addPrefix("dct:","http://purl.org/dc/terms/"),this.classLookup={},this.classLookup[this.rdfsResource]=g,this.nodes={}}inCache(e){return e in this.nodes}set setWarnings(e){this.showWarnings=e}warn(e){this.showWarnings&&console.warn(e)}lookupClass(e,t){return this.classLookup[e]?this.classLookup[e]:t}getAllElements(){this.warn("This has been deprecated - who wants to get everything at once ?")}addPrefix(e,t){if(e.slice(-1)!=":")throw j;this.prefixDict[e]=t}set defaultNamespace(e){this.addPrefix(":",e)}get defaultNamespace(){return this.prefixDict[":"]}getPrefix(e){const t=Object.keys(this.prefixDict),s=Object.values(this.prefixDict);return t.find((i,r)=>s[r]===e)||e}shorten(e){const t=Object.keys(this.prefixDict).find(s=>e.includes(this.prefixDict[s]));return t?e.replace(this.prefixDict[t],t):e}getSparqlPrefix(e){if(e in this.prefixDict)return`PREFIX ${e} <${this.prefixDict[e]}> `;throw W+e}get sparqlPrefixes(){let e="";for(const t in this.prefixDict)e=e+`PREFIX ${t} <${this.prefixDict[t]}> `;return e}mintUri(e=this.defaultNamespace){return e+crypto.randomUUID()}async runQuery(e){if(y(e))throw Error("runQuery: A valid query is required");const t=await fetch(this.queryEndpoint+encodeURIComponent(this.sparqlPrefixes+e),{headers:{Expects:"application/sparql-results+json"}});if(!t.ok)throw t.statusText;return await t.json()}async checkTripleStore(){return"boolean"in await this.runQuery("ASK WHERE {}")}async runUpdate(e,t){let s=this.sparqlPrefixes;if(e.forEach(i=>{s=`${s}
      ${i} ;
      `,this.updateCount=this.updateCount+1}),U(this,w)){const i=t??this.defaultSecurityLabel;y(i)&&this.warn("Security label is being set to an empty string. Please check your security policy as this may make the data inaccessible");const r={method:"POST",headers:{Accept:"*/*","Content-Type":"application/sparql-update"},body:this.sparqlPrefixes+s},a=await fetch(this.updateEndpoint,r);if(!a.ok)throw a.statusText;return a.text()}else return this.warn("service is in read only node, updates are not permitted"),"service is in read only node, updates are not permitted"}async insertTriple(e,t,s,i,r,a,n=!1){const c=[];n&&c.push(`DELETE WHERE {<${e}> <${t}> ?o}`);const h=O(this,m,C).call(this,s,i,a);return c.push(`INSERT DATA {<${e}> <${t}> ${h} . }`),await this.runUpdate(c,r)}async deleteTriple(e,t,s,i,r){const a=O(this,m,C).call(this,s,i,r);return await this.runUpdate(["DELETE DATA {<"+e+"> <"+t+"> "+a+" . }"])}async deleteNode(e,t=!1){if(y(e))throw Error(P);return t?await this.runUpdate(["DELETE WHERE {<"+e+"> ?p ?o . }"]):await this.runUpdate(["DELETE WHERE {?s ?p <"+e+">}"])}async deleteRelationships(e,t){if(y(e))throw Error(P);if(y(t))throw Error("Cannot have an empty predicate");return await this.runUpdate([`DELETE WHERE {<${e}> <${t}> ?o . }`])}instantiate(e,t,s){if(y(e))throw Error("Cannot have an empty cls");return t||(t=this.mintUri()),this.insertTriple(t,this.rdfType,e,void 0,s),t}async find(e,t){let s="";t&&(s=`
      BIND (STR(?type) AS ?typestr) .
      FILTER (?typestr in (${'"'+t.join('", "')+'"'}) ) .
      `);const i=`
        SELECT ?uri (group_concat(DISTINCT ?type) as ?_type) (group_concat(DISTINCT ?literal) as ?concatLit)
        WHERE {
            ?uri a ?type .
            ?uri ?pred ?literal .
            ${s}
            FILTER CONTAINS(LCASE(?literal), "${e.toLowerCase()}")
        } GROUP BY ?uri
        `,r=await this.runQuery(i);return this.rankedWrap(r,e)}compareScores(e,t){return!e.score||!t.score?0:e.score<t.score?1:e.score>t.score?-1:0}rankedWrap(e,t){const s=[];let i=g;const r=new RegExp(t.toLowerCase(),"g");let a="";if(t&&t!=""&&e.results&&e.results.bindings&&e.head&&e.head.vars)for(const n in e.results.bindings){const c=e.results.bindings[n];if(c._type){const v=c._type.value.split(" ");i=this.lookupClass(v[0],g)}else i=g;const h=new i(this,void 0,void 0,c);let p=0;if(c.concatLit){a=c.concatLit.value;const v=a.match(r);v&&(p=v.length)}const f={item:h,score:p};s.push(f)}return s.sort(this.compareScores)}makeTypedStatement(e,t){return{uri:{value:e,type:"URI"},_type:{value:t,type:"URI"}}}}w=new WeakMap,m=new WeakSet,C=function(l,e="URI",t){let s="";if(e==="URI")s=`<${l}>`;else if(e=="LITERAL")s=`"${l}"`,t&&(s=`${s}^^${t}`);else throw new Error("unknown objectType");return s};class F{constructor(e,t){o(this,"cls"),o(this,"style"),this.cls=e,this.style=t}}class E extends g{constructor(e,t,s,i,r){super(e,t,e.telDiagram,r),o(this,"uuid"),o(this,"title"),o(this,"service"),this.service=e,this.uuid="",this.title="",r?(r.uuid&&(this.uuid=r.uuid.value),r.title&&(this.title=r.title.value)):(s||(s=crypto.randomUUID()),this.setUUID(s),t||(t=this.service.mintUri()),i&&this.setTitle(i))}async setUUID(e,t){this.addLiteral(this.service.telUUID,e,t,"xsd:string",!0)}async getDiagramElements(){const e=`SELECT ?uri ?_type ?style ?element ?baseType
      WHERE {
        ?uri a ?_type .
        FILTER  (?_type IN (<${this.service.telDiagramElement}>,<${this.service.telDiagramPropertyDefinition}>))
        ?uri <${this.service.telInDiagram}> <${this.uri}> .
        ?uri <${this.service.telRepresents}> ?element .
        OPTIONAL {?uri <${this.service.telBaseType}> ?baseType }
        OPTIONAL {?uri <${this.service.telElementStyle}> ?style }
      }`,t=await this.service.runQuery(e),s=[];return t.results.bindings.forEach(i=>{let r=this.service.telDiagramElement;i._type&&(r=i._type.value);const a=this.service.lookupClass(r,this.service.telDiagramElement),n=new a(this.service,void 0,void 0,i);i.baseType?n.baseType=i.baseType.value:n.baseType=this.service.rdfsResource;const c=this.service.lookupClass(n.baseType,this.service.rdfsResource);i.element.value in this.service.nodes?n.element=this.service.nodes[i.element.value]:n.element=new c(this.service,void 0,void 0,this.service.makeTypedStatement(i.element.value,n.baseType)),i.style&&(n.style=JSON.parse(decodeURIComponent(i.style.value))),s.push(n)}),s}async getDiagramRelations(){const e=`SELECT ?uri ?_type ?source ?target ?style ?rel 
      WHERE {
        BIND (<${this.service.telDiagramRelationship}> as ?_type) .
        ?uri a ?_type .
        ?uri <${this.service.telInDiagram}> <${this.uri}> .
        ?uri <${this.service.telRepresents}> ?rel .
        ?uri <${this.service.telSourceElem}> ?source .
        ?uri <${this.service.telTargetElem}> ?target .
        OPTIONAL {?uri <${this.service.telRelationshipStyle}> ?style }
      }`,t=await this.service.runQuery(e),s=[];return t.results.bindings.forEach(i=>{const r={uri:i.uri.value};i.source.value in this.service.nodes?r.source=this.service.nodes[i.source.value]:r.source=new T(this.service,void 0,void 0,this.service.makeTypedStatement(i.source.value,this.service.telDiagramElement)),i.target.value in this.service.nodes?r.target=this.service.nodes[i.target.value]:r.target=new T(this.service,void 0,void 0,this.service.makeTypedStatement(i.target.value,this.service.telDiagramElement)),r.relationship=i.rel.value,i.style&&(r.style=JSON.parse(decodeURIComponent(i.style.value))),s.push(r)}),s}}class I extends g{constructor(e,t,s="http://www.w3.org/2000/01/rdf-schema#Resource",i){super(e,t,s,i),o(this,"service"),this.service=e}setStyle(e){const t=encodeURIComponent(JSON.stringify(e));this.service.insertTriple(this.uri,this.service.telicentStyle,t,"LITERAL",void 0,void 0,!0)}async describe(){}async getDiagrams(){const e=[],t=`SELECT ?uri (group_concat(DISTINCT ?uuids) as ?uuid) (group_concat(DISTINCT ?titles) as ?title)  (group_concat(DISTINCT ?type) as ?_type)
      WHERE {
        BIND (<${this.service.telDiagram}> as ?type) .
        ?diagramObject <${this.service.telRepresents}> <${this.uri}> .
        ?diagramObject <${this.service.telInDiagram}> ?uri .
        ?uri a ?type .
        OPTIONAL { ?uri <${this.service.dcTitle}> ?titles }
        OPTIONAL { ?uri <${this.service.telUUID}> ?uuids }
      } GROUP BY ?uri`;return(await this.service.runQuery(t)).results.bindings.forEach(s=>{e.push(new E(this.service,void 0,void 0,void 0,s))}),e}}class T extends I{constructor(e,t,s=e.telDiagramElement,i){super(e,t,s,i),o(this,"style"),o(this,"element"),o(this,"baseType"),o(this,"service"),this.service=e}}class B extends T{constructor(e,t,s=e.telDiagramPropertyDefinition,i){super(e,t,s,i),o(this,"domain"),o(this,"range"),this.service=e}}class d extends I{constructor(e,t,s="http://www.w3.org/1999/02/22-rdf-syntax-ns#Property",i){super(e,t,s,i),this.service=e}async getNodes(e,t=[]){return[]}async describe(){const e=await this.describeNode("http://telicent.io/ontology/inDiagram"),t={style:void 0,labels:[],comments:[],domains:[],ranges:[],diagramElements:[],superProperties:[],subProperties:[],inLinks:{},outLinks:{},literals:{}};return Object.keys(e.literals).forEach(s=>{const i=e.literals[s];switch(s){case this.service.rdfsComment:{t.comments=i;break}case this.service.rdfsLabel:{t.labels=i;break}case this.service.telicentStyle:{t.style=JSON.parse(decodeURIComponent(i[0]));break}default:t.literals[s]=i}}),Object.keys(e.outLinks).forEach(s=>{const i=e.outLinks[s];switch(s){case this.service.rdfsSubPropertyOf:{this.service.processObjectLink(i,s,t.superProperties);break}case this.service.rdfsRange:{this.service.processObjectLink(i,s,t.ranges);break}case this.service.rdfsDomain:{this.service.processObjectLink(i,s,t.domains);break}default:t.outLinks[s]=[],this.service.processObjectLink(i,s,t.outLinks[s])}}),Object.keys(e.inLinks).forEach(s=>{const i=e.inLinks[s];switch(s){case this.service.rdfsSubPropertyOf:{this.service.processObjectLink(i,s,t.subProperties);break}case this.service.telRepresents:{this.service.processObjectLink(i,s,t.diagramElements);break}default:t.inLinks[s]=[],this.service.processObjectLink(i,s,t.inLinks[s])}}),t}async setDomain(e,t=!0){return t&&await this.service.deleteRelationships(this.uri,this.service.rdfsDomain),await this.service.insertTriple(this.uri,this.service.rdfsDomain,e.uri)}async setRange(e,t=!0){let s="";return t&&await this.service.deleteRelationships(this.uri,this.service.rdfsRange),e instanceof b?s=e.uri:s=e.replace("xsd:",this.service.xsd),await this.service.insertTriple(this.uri,this.service.rdfsRange,s)}async addSubProperty(e){let t="";if(typeof e=="string"){t=e,this.service.insertTriple(t,this.service.rdfsSubPropertyOf,this.uri);const s={uri:{value:t,type:""},_type:{value:"",type:""}};return new d(this.service,void 0,void 0,s)}else return t=e.uri,this.service.insertTriple(t,this.service.rdfsSubPropertyOf,this.uri),e}async addSuperProperty(e){let t="";if(typeof e=="string"){t=e,this.service.insertTriple(this.uri,this.service.rdfsSubPropertyOf,t);const s={uri:{value:t,type:""},_type:{value:"",type:""}};return new d(this.service,void 0,void 0,s)}else return t=e.uri,this.service.insertTriple(this.uri,this.service.rdfsSubPropertyOf,t),e}async getSubProperties(e=!1){let t="";e&&(t="*");const s=`SELECT ?uri (group_concat(DISTINCT ?type) as ?_type) WHERE {?uri rdfs:subPropertyOf${t} <${this.uri}> . ?uri a ?type} GROUP BY ?uri`,i=await this.service.runQuery(s),r=[];let a=d;for(const n of i.results.bindings){n._type&&(a=this.service.lookupClass(n._type.value,d));const c=new a(this.service,void 0,void 0,n);r.push(c)}return r}}class Q extends d{constructor(e,t,s="http://www.w3.org/2002/07/owl#ObjectProperty",i){super(e,t,s,i),this.service=e}async setRange(e,t=!0){return super.setRange(e,t)}}class q extends d{constructor(e,t,s="http://www.w3.org/2002/07/owl#DatatypeProperty",i){super(e,t,s,i),this.service=e}async setRange(e,t=!0){return super.setRange(e,t)}}class b extends I{constructor(e,t,s=e.rdfsClass,i,r){super(e,t,s,i),o(this,"service"),this.service=e,i?r&&this.service.warn("Do not set superClass parameter if creating class from a query"):r&&this.service.insertTriple(this.uri,this.service.rdfsSubClassOf,r.uri)}async describe(){const e=await this.describeNode("http://telicent.io/ontology/inDiagram"),t={style:void 0,labels:[],comments:[],isDomainFor:[],isRangeFor:[],diagramElements:[],superClasses:[],subClasses:[],inLinks:{},outLinks:{},literals:{}};return Object.keys(e.literals).forEach(s=>{const i=e.literals[s];switch(s){case this.service.rdfsComment:{t.comments=i;break}case this.service.rdfsLabel:{t.labels=i;break}case this.service.telicentStyle:{t.style=JSON.parse(decodeURIComponent(i[0]));break}default:t.literals[s]=i}}),Object.keys(e.outLinks).forEach(s=>{const i=e.outLinks[s];switch(s){case this.service.rdfsSubClassOf:{this.service.processObjectLink(i,s,t.superClasses);break}default:t.outLinks[s]=[],this.service.processObjectLink(i,s,t.outLinks[s])}}),Object.keys(e.inLinks).forEach(s=>{const i=e.inLinks[s];switch(s){case this.service.rdfsSubClassOf:{this.service.processObjectLink(i,s,t.subClasses);break}case this.service.rdfsRange:{this.service.processObjectLink(i,s,t.isRangeFor);break}case this.service.rdfsDomain:{this.service.processObjectLink(i,s,t.isDomainFor);break}case this.service.telRepresents:{this.service.processObjectLink(i,s,t.diagramElements);break}default:t.inLinks[s]=[],this.service.processObjectLink(i,s,t.inLinks[s])}}),t}async getSubClasses(e=!1){let t="";e&&(t="*");const s=`SELECT ?uri (group_concat(DISTINCT ?type) as ?_type) WHERE {?uri rdfs:subClassOf${t} <${this.uri}> . ?uri a ?type} GROUP BY ?uri`,i=await this.service.runQuery(s);return this.service.wrapClasses(i,this.uri)}async getSuperClasses(e=!1){const t=e?"*":"",s=`SELECT ?uri (group_concat(DISTINCT ?type) as ?_type) WHERE {<${this.uri}> <${this.service.rdfsSubClassOf}>${t} ?uri . ?uri a type .} GROUP BY ?uri`,i=await this.service.runQuery(s);return this.service.wrapClasses(i,this.uri)}async getOwnedProperties(e=!1){let t=`SELECT ?uri ?_type WHERE {?uri rdfs:domain <${this.uri}> . ?uri a ?_type }`;e&&(t=`SELECT ?uri ?_type WHERE {?uri rdfs:domain ?super . <${this.uri}> rdfs:subClassOf* ?super . ?uri a ?_type }`);const s=await this.service.runQuery(t),i=[];let r=d;for(const a of s.results.bindings){a._type&&(r=this.service.lookupClass(a._type.value,d));const n=new r(this.service,void 0,void 0,a);i.push(n)}return i}async getReferringProperties(e=!1){let t=`SELECT ?uri ?_type WHERE {?uri rdfs:range <${this.uri}> . ?uri a ?_type }`;e&&(t=`SELECT ?uri ?_type WHERE {?uri rdfs:range ?super . <${this.uri}> rdfs:subClassOf* ?super . ?uri a ?_type }`);const s=await this.service.runQuery(t),i=[];let r=d;for(const a of s.results.bindings){a._type&&(r=this.service.lookupClass(a._type.value,d));const n=new r(this.service,void 0,void 0,a);i.push(n)}return i}async addSubClass(e){let t="";if(typeof e=="string"){t=e,this.service.insertTriple(t,this.service.rdfsSubClassOf,this.uri);const s={uri:{value:t,type:""},_type:{value:"",type:""}};return new b(this.service,void 0,void 0,s)}else return t=e.uri,this.service.insertTriple(t,this.service.rdfsSubClassOf,this.uri),e}async addSuperClass(e){let t="";if(typeof e=="string"){t=e,this.service.insertTriple(this.uri,this.service.rdfsSubClassOf,t);const s={uri:{value:t,type:""},_type:{value:"",type:""}};return new b(this.service,void 0,void 0,s)}else return t=e.uri,this.service.insertTriple(this.uri,this.service.rdfsSubClassOf,t),e}}class G extends b{constructor(e,t,s=e.rdfsDatatype,i,r){super(e,t,s,i,r)}}class J extends b{constructor(e,t,s=e.owlClass,i,r){super(e,t,s,i,r)}}class Z extends H{constructor(e="http://localhost:3030/",t="ontology",s="http://telicent.io/ontology/",i="",r=!1){super(e,t,s,i,r),o(this,"telDiagram"),o(this,"telUUID"),o(this,"telElementStyle"),o(this,"telRelationshipStyle"),o(this,"telInDiagram"),o(this,"telRepresents"),o(this,"telBaseType"),o(this,"telDiagramElement"),o(this,"telDiagramRelationship"),o(this,"telDiagramPropertyDefinition"),o(this,"telRouting"),o(this,"telDisplayAs"),o(this,"telSourceElem"),o(this,"telTargetElem"),o(this,"rdfsClass"),o(this,"rdfsDatatype"),o(this,"rdfsSubClassOf"),o(this,"rdfsDomain"),o(this,"rdfsRange"),o(this,"rdfProperty"),o(this,"rdfsSubPropertyOf"),o(this,"owlClass"),o(this,"owlDatatypeProperty"),o(this,"owlObjectProperty"),o(this,"telicentStyle"),this.telDiagram=this.telicent+"Diagram",this.telUUID=this.telicent+"uuid",this.telElementStyle=this.telicent+"elementStyle",this.telRelationshipStyle=this.telicent+"relationshipStyle",this.telInDiagram=this.telicent+"inDiagram",this.telRepresents=this.telicent+"represents",this.telBaseType=this.telicent+"baseType",this.telDiagramElement=this.telicent+"DiagramElement",this.telDiagramRelationship=this.telicent+"DiagramRelationship",this.telDiagramPropertyDefinition=this.telicent+"DiagramPropertyDefinition",this.telRouting=this.telicent+"routing",this.telDisplayAs=this.telicent+"displayAs",this.telSourceElem=this.telicent+"sourceElem",this.telTargetElem=this.telicent+"targetElem",this.rdfsClass=`${this.rdfs}Class`,this.rdfsDatatype=`${this.rdfs}Datatype`,this.rdfsSubClassOf=`${this.rdfs}subClassOf`,this.rdfsDomain=`${this.rdfs}domain`,this.rdfsRange=`${this.rdfs}range`,this.rdfProperty=`${this.rdf}Property`,this.rdfsSubPropertyOf=`${this.rdfs}subPropertyOf`,this.owlClass=`${this.owl}Class`,this.owlDatatypeProperty=`${this.owl}DatatypeProperty`,this.owlObjectProperty=`${this.owl}ObjectProperty`,this.telicentStyle=`${this.telicent}style`,this.classLookup[this.rdfProperty]=d,this.classLookup[this.owlClass]=J,this.classLookup[this.owlDatatypeProperty]=q,this.classLookup[this.owlObjectProperty]=Q,this.classLookup[this.rdfsClass]=b,this.classLookup[this.rdfsDatatype]=G,this.classLookup[this.telDiagramElement]=T,this.classLookup[this.telDiagram]=E,this.classLookup[this.telDiagramPropertyDefinition]=B,this.addPrefix("owl:",this.owl)}processObjectLink(e,t,s,i=g){Object.keys(e).forEach(r=>{const a={uri:{value:r,type:"uri"},_type:{value:e[r].join(" "),type:"uri"}},n=this.lookupClass(e[r][0],i),c=new n(this,void 0,void 0,a);s.push(c)})}wrapClasses(e,t){const s=[];let i=b;return e.results.bindings.forEach(r=>{if(r.uri.value!=t)if(r.uri.value in this.nodes)s.push(this.nodes[r.uri.value]);else{if(r._type){const n=r._type.value.split(" ");i=this.lookupClass(n[0],b)}const a=new i(this,void 0,void 0,r);s.push(a)}}),s}async getAllRdfProperties(e=!0,t=!1){let s="";t&&(s=`FILTER NOT EXISTS {
        ?uri rdfs:subPropertyOf ?parentProp
      }`);let i=`WHERE {BIND (rdf:Property as ?_type . ?uri a ?_type ) . ${s}}`;e&&(i=`WHERE {?uri a ?_type . FILTER (?_type IN (owl:ObjectProperty, owl:DatatypeProperty, rdf:Property)) . ${s}}`);const r=`SELECT ?uri ?_type ${i}`,a=await this.runQuery(r),n=[];let c=d;for(const h of a.results.bindings){h._type&&(c=this.lookupClass(h._type.value,d));const p=new c(this,void 0,void 0,h);n.push(p)}return n}async getTopProperties(e=!0){return await this.getAllRdfProperties(e,!0)}async getAllObjectProperties(){const e=`
      SELECT
        ?uri ?_type
      WHERE {
        BIND (owl:ObjectProperty as ?_type)
        ?uri a ?_type
      }
    `,t=(await this.runQuery(e)).results.bindings,s=[];return t.forEach(i=>{const r=new d(this,void 0,void 0,i);s.push(r)}),s}async getAllClasses(e=!0,t=!1){let s="";t&&(s=`FILTER NOT EXISTS {
          ?uri rdfs:subClassOf ?parentClass
        }`);let i=`WHERE {BIND (rdfs:Class as ?type . ?uri a ?type ) . ${s}}`;e&&(i=`WHERE {?uri a ?type . FILTER (?type IN (owl:Class, rdfs:Class)) . ${s}}`);const r=`SELECT ?uri (group_concat(DISTINCT ?type) as ?_type) ${i} GROUP BY ?uri`,a=await this.runQuery(r);return this.wrapClasses(a)}async getTopClasses(){return await this.getAllClasses(!0,!0)}async getAppliedStyles(e=[]){let t="";e.length>0&&(t='FILTER (str(?cls) IN ("'+e.join('", "')+'") )');const s=`SELECT ?cls ?style WHERE {?cls <${this.telicentStyle}> ?style . ${t} }`;return(await this.runQuery(s)).results.bindings.map(i=>new F(i.cls.value,JSON.parse(decodeURIComponent(i.style.value))))}async getStyles(e){const t=e.length>0?'FILTER (str(?cls) IN ("'+e.join('", "')+'") )':"",s=`SELECT ?cls ?style WHERE {?cls <${this.telicentStyle}> ?style . ${t} }`;return(await this.runQuery(s)).results.bindings.reduce((i,r)=>{try{const a=JSON.parse(decodeURIComponent(r.style.value));i[r.cls.value]={defaultIcons:{riIcon:"",faIcon:a.icon,faUnicode:a.faUnicode,faClass:a.faClass},defaultStyles:{shape:a.shape,borderRadius:"",borderWidth:"",selectedBorderWidth:"",dark:{backgroundColor:"",color:a.light},light:{backgroundColor:"",color:a.light}}}}catch{console.warn(`Could not parse styles for ${r.cls.value}`)}return i},{})}setStyle(e,t){const s=encodeURIComponent(JSON.stringify(t));this.deleteRelationships(e,this.telicentStyle),this.insertTriple(e,this.telicentStyle,s,"LITERAL")}async getAllDiagrams(){const e=`SELECT ?uri ?uuid ?title WHERE {
            ?uri a <${this.telDiagram}> . 
            OPTIONAL {?uri <${this.telUUID}> ?uuid} 
            ?uri <${this.dcTitle}> ?title .
        }`,t=(await this.runQuery(e)).results.bindings,s=[];return t.forEach(i=>{const r=new E(this,void 0,void 0,void 0,i);s.push(r)}),s}async getDiagram(e){const t=`
        SELECT ?uri ?_type ?uuid ?title  WHERE {
            BIND(<${e}> as ?uri)
            BIND(<${this.telDiagram}> as ?_type)
            ?uri a <${this.telDiagram}> . 
            OPTIONAL {<${e}> <${this.telUUID}> ?uuid} 
            OPTIONAL {<${e}> <${this.dcTitle}> ?title } 
        }`,s=(await this.runQuery(t)).results.bindings;if(s.length>1){this.warn(`More than one diagram found from getDiagram query with provided URI: ${e}`);return}else if(s.length<1){this.warn(`No diagram with URI ${e} found from getDiagram query`);return}else return new E(this,void 0,void 0,void 0,s[0])}async getHierarchy(e="rdfs:Class, owl:Class",t="rdfs:subClassOf"){var s;const i=`SELECT 
    ?uri 
    (group_concat(DISTINCT ?type) as ?_type) 
    (group_concat(DISTINCT ?sub) as ?subs) 
    (group_concat(DISTINCT ?label; SEPARATOR="||") as ?labels) 
    (group_concat(DISTINCT ?style; SEPARATOR="||") as ?styles) 
    (group_concat(DISTINCT ?super) as ?supers) 
    WHERE {
      ?uri a ?type .
      FILTER (?type IN (${e}))
      OPTIONAL {  ?sub ${t} ?uri }
      OPTIONAL { ?uri ${t} ?super }
      OPTIONAL { ?uri rdfs:label ?label }
      OPTIONAL { ?uri telicent:style ?style }
    } GROUP BY ?uri`,r=await this.runQuery(i),a={},n=[];let c;return t=="rdfs:subPropertyOf"?c=d:c=b,((s=r.results)==null?void 0:s.bindings.length)>0&&(r.results.bindings.forEach(h=>{let p=c;if(h._type){const v=h._type.value.split(" ");p=this.lookupClass(v[0],c)}const f={item:new p(this,void 0,void 0,h),id:h.uri.value,label:"",rdfsLabels:[],children:[],parents:[],style:void 0,expanded:!1};if(h.labels&&(f.rdfsLabels=h.labels.value.split("||")),h.styles){const v=h.styles.value.split("||");try{f.style=JSON.parse(decodeURIComponent(v[0]))}catch{this.warn(`Unable to decode style for URI ${h.uri.value}`)}}h.supers||n.push(f),a[h.uri.value]=f}),r.results.bindings.forEach(h=>{const p=a[h.uri.value];p.rdfsLabels.length>0?p.label=p.rdfsLabels[0]:p.label=this.shorten(h.uri.value),h.supers&&h.supers.value.split(" ").forEach(f=>{const v=a[f];p.parents.push(v)}),h.subs&&h.subs.value.split(" ").forEach(f=>{const v=a[f];p.children.push(v)})})),n}async getClassHierarchy(){return await this.getHierarchy("rdfs:Class, owl:Class, rdfs:Datatype","rdfs:subClassOf")}async getPropertyHierarchy(){return await this.getHierarchy("rdf:Property, owl:ObjectProperty, owl:DatatypeProperty, owl:AnnotationProperty, owl:AsymmetricProperty, owl:DeprecatedProperty, owl:FunctionalProperty, owl:OntologyProperty, owl:InverseFunctionalProperty, owl:IrreflexiveProperty, owl:ReflexiveProperty,owl:SymmetricProperty, owl:TransitiveProperty","rdfs:subPropertyOf")}}const M=l=>{const e={width:48,height:48};switch(l){case"xs":return{width:24,height:24,fontSize:8};case"sm":return{width:36,height:36,fontSize:10};case"lg":return{width:62,height:62,fontSize:22};default:return e}},Y=l=>l?{filter:"grayscale(0.7)",opacity:"80%"}:{},X=({type:l="",borderColor:e,disabled:t=!1,size:s="base"})=>{const{findIcon:i}=k(),r=i(l),a=!!(r!=null&&r.faIcon);return L(R,{alt:r.alt,"aria-label":r.alt,sx:{borderWidth:2,bordericonProps:"solid",borderColor:e??r.color,color:r.color,backgroundColor:r.backgroundColor,...Y(t),...M(s)},children:a?L("i",{className:r.faIcon,title:`${r.alt}-icon`}):L("p",{children:r.iconFallbackText})})};X.__docgenInfo={description:`This component can be used to display type/class iconography defined in the
ontology. If the styles cannot be found, the initials will be rendered as a
fallback as demonstrated in the stories.`,methods:[],displayName:"TeliTypeIcon",props:{type:{defaultValue:{value:'""',computed:!1},required:!1},disabled:{defaultValue:{value:"false",computed:!1},required:!1},size:{defaultValue:{value:'"base"',computed:!1},required:!1}}};export{Z as M,X as T};
